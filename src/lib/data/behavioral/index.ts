import type { Challenge } from '../../types';

export const behavioralChallenges: Challenge[] = [
  {
    id: 'bh-001',
    category: 'behavioral',
    subcategory: 'star-method',
    title: 'Disagreeing with a Technical Decision',
    difficulty: 3,
    type: 'EXPLAIN',
    description: 'Tell me about a time you disagreed with a technical decision made by your team or lead. How did you handle it? Use the STAR method (Situation, Task, Action, Result) to structure your response.',
    solution: 'Model Answer using STAR:\n\nSituation: Our team was building a real-time dashboard. The tech lead decided to use WebSockets with a custom implementation instead of using Server-Sent Events (SSE) or an established library like Socket.io.\n\nTask: I needed to voice my concerns constructively without undermining the lead or creating team friction, while ensuring we made the best technical decision.\n\nAction: I scheduled a 1:1 with the lead rather than raising it in a group meeting. I prepared a comparison document showing: (1) our requirements were unidirectional (server to client), making SSE sufficient, (2) the custom WebSocket implementation would need reconnection logic, heartbeats, and message queuing that Socket.io already handles, (3) estimated extra development time for the custom approach. I framed it as "I want to make sure we have considered this alternative" rather than "you are wrong." I also acknowledged the legitimate reasons for the custom approach (no dependency, full control).\n\nResult: The lead appreciated the thorough analysis and agreed SSE was simpler for our unidirectional use case. We saved an estimated 2 weeks of development time. More importantly, the lead started inviting me to architecture discussions earlier, and the team adopted a practice of writing brief RFC documents for significant technical decisions.',
    solutionExplanation: 'This question tests conflict resolution, technical communication, and professional maturity. Strong answers show: (1) you disagree with data, not emotion, (2) you choose the right setting (private 1:1, not public challenge), (3) you frame disagreement as exploration ("have we considered") not confrontation ("that is wrong"), (4) you acknowledge the other person\'s reasoning, (5) the result includes both the technical outcome AND the relationship/process improvement.',
    hints: ['Use STAR format strictly. The strongest answers show that you led with data and chose a private setting for the disagreement.', 'The result should include both the technical outcome and the relationship outcome. Did the process improve for future decisions?'],
    tags: ['star-method', 'conflict-resolution', 'communication', 'leadership'],
    estimatedMinutes: 8,
    conceptSections: [
      {
        title: 'Setting the Scene (Situation & Task)',
        keyTakeaway: 'A strong STAR response begins with a specific, concrete scenario that establishes context — not a generic "sometimes I disagree" statement.',
        explanation: 'The Situation sets the stage with enough detail for the interviewer to understand the stakes. Mention the project, the technology decision, and who made it. The Task defines YOUR role and responsibility — what was your specific obligation? Avoid vague setups. "We were building a real-time dashboard and the lead chose custom WebSockets over SSE" is much stronger than "my team made a decision I disagreed with." The interviewer needs to understand WHY the disagreement mattered, not just that it happened.',
        relatedPatterns: ['STAR Method', 'Situational Leadership', 'Stakeholder Analysis'],
      },
      {
        title: 'Choosing the Right Setting',
        keyTakeaway: 'Raise disagreements in private (1:1), not in group settings. This protects the other person\'s authority and creates space for honest discussion.',
        explanation: 'The channel you choose for disagreement is as important as the content. A 1:1 meeting signals respect and creates psychological safety for both parties. Public challenges feel like attacks regardless of intent, and they force people into defensive positions. Scheduling a dedicated meeting also shows you take the issue seriously enough to prepare, rather than ambushing someone in a standup. This is a key leadership behavior that interviewers specifically look for — it demonstrates emotional intelligence and organizational awareness.',
        relatedPatterns: ['Psychological Safety', 'Feedback Frameworks', 'Radical Candor'],
      },
      {
        title: 'Data-Driven Argumentation',
        keyTakeaway: 'Frame disagreements as exploration ("have we considered X?") backed by evidence, not as challenges ("you are wrong about Y").',
        explanation: 'Prepare a comparison document or evidence before the conversation. Include concrete data: time estimates, technical trade-offs, precedents, or proof-of-concepts. Framing as "I want to make sure we have considered this alternative" invites collaboration rather than confrontation. Critically, acknowledge the legitimate reasons for the original decision — this shows you understand their reasoning and are not dismissing it. The strongest technical disagreements are ones where you can articulate BOTH sides clearly and still make a case for your preferred approach.',
        relatedPatterns: ['RFC Documents', 'Architecture Decision Records', 'Devil\'s Advocate'],
      },
      {
        title: 'Outcome and Growth',
        keyTakeaway: 'The best results include both the immediate technical outcome AND a lasting process improvement (like adopting RFC documents for future decisions).',
        explanation: 'Interviewers care about what happened, but they care even more about what you LEARNED and how the process improved. A purely technical outcome ("we saved 2 weeks") is good. A systemic improvement ("the team adopted RFC documents for architecture decisions") is great. It shows you think beyond individual incidents and improve how the team operates. Also mention the relationship outcome — did the disagreement damage trust or strengthen it? The ideal story ends with increased trust and better collaboration.',
        relatedPatterns: ['Retrospectives', 'Continuous Improvement', 'Blameless Culture'],
      },
    ],
  },
  {
    id: 'bh-002',
    category: 'behavioral',
    subcategory: 'star-method',
    title: 'Most Challenging Debugging Experience',
    difficulty: 3,
    type: 'EXPLAIN',
    description: 'Describe your most challenging debugging experience. Walk through how you identified the issue, what tools and techniques you used, and what you learned. Use the STAR method.',
    solution: 'Model Answer:\n\nSituation: Our production e-commerce app had intermittent checkout failures — about 5% of transactions were silently failing. No errors in our application logs, no alerts triggered. Customer complaints were the only signal.\n\nTask: I was assigned to find and fix the root cause, which had been unresolved for 2 weeks.\n\nAction: I followed a systematic debugging approach:\n1. Reproduced: Analyzed failed transactions to find a pattern. Discovered failures correlated with high-traffic periods.\n2. Traced: Added request correlation IDs and verbose logging at every step of the checkout flow.\n3. Narrowed: Logs revealed requests were reaching our payment service but responses were not coming back. Connection timeout after 30 seconds.\n4. Investigated: The payment service was healthy. Used network monitoring (tcpdump) to see that responses WERE being sent.\n5. Root cause: Our load balancer had a connection pool limit of 100. Under load, new connections were being dropped silently. The 30-second timeout was not in our app — it was the load balancer default.\n6. Fixed: Increased connection pool limit, added connection pool monitoring alerts, added explicit timeout handling in our code with retry logic.\n\nResult: Checkout success rate went from 95% to 99.8%. More importantly, I documented the debugging process and we added load balancer metrics to our monitoring dashboard, preventing similar silent failures.',
    solutionExplanation: 'This reveals systematic thinking and debugging methodology. Strong answers show: (1) a structured approach to narrowing down the problem, (2) use of specific tools (logs, network tools, metrics), (3) the root cause is not obvious (it\'s infrastructure, not code), (4) the fix includes both immediate resolution and prevention. Avoid vague answers like "I debugged it and fixed it." Show the HOW.',
    hints: ['Walk through your debugging methodology step by step. Show how you narrowed down from many possibilities to the root cause.', 'The best debugging stories involve something unexpected — where the bug was not where you initially looked. Infrastructure, race conditions, and configuration issues make compelling examples.'],
    tags: ['star-method', 'debugging', 'problem-solving', 'systematic-thinking'],
    estimatedMinutes: 8,
  },
  {
    id: 'bh-003',
    category: 'behavioral',
    subcategory: 'star-method',
    title: 'Project Falling Behind Schedule',
    difficulty: 3,
    type: 'EXPLAIN',
    description: 'How did you handle a project that was falling behind schedule? What steps did you take, and what was the outcome? Use the STAR method.',
    solution: 'Model Answer:\n\nSituation: Our team was 3 weeks into a 6-week sprint to rebuild the user onboarding flow. At the midpoint review, we were only 30% complete. The scope had expanded because the PM added A/B testing requirements and the API team had delivered a different contract than expected.\n\nTask: As the senior engineer on the project, I needed to get us back on track without burning out the team or delivering a broken product.\n\nAction:\n1. Honest assessment: I mapped all remaining work items, estimated them honestly, and identified the gap. We needed 8 more weeks at current pace but had 3.\n2. Scope negotiation: I scheduled a meeting with the PM and engineering lead. Presented the situation with data, not emotion. Proposed splitting into two releases: MVP onboarding (must-haves) and enhanced onboarding (A/B testing, analytics).\n3. Technical de-risking: I identified the API contract mismatch as the biggest risk and paired with the API team for one day to align on a concrete spec.\n4. Team communication: I was transparent with the team about the situation and the adjusted scope. Reassigned work to play to individual strengths.\n5. Execution: Implemented daily 10-minute standups (instead of twice-weekly) to catch blockers early.\n\nResult: We shipped the MVP onboarding on time. The enhanced version shipped 2 weeks later. The PM appreciated the transparency and started including engineering in scope discussions earlier. The team morale actually improved because they felt heard and the workload became realistic.',
    solutionExplanation: 'This tests project management skills, communication, and leadership. Strong answers show: (1) early recognition of the problem with data, (2) proactive communication with stakeholders, (3) scope negotiation (not heroic overtime), (4) concrete actions taken, (5) positive outcome for both the project and the team. The worst answer is "I worked weekends to catch up" because it does not solve the systemic problem.',
    hints: ['The strongest answers involve scope negotiation, not just working harder. Show that you identified what is truly essential versus nice-to-have.', 'Emphasize data-driven communication with stakeholders. "We need 8 weeks but have 3" is more persuasive than "we are behind."'],
    tags: ['star-method', 'project-management', 'leadership', 'communication'],
    estimatedMinutes: 8,
  },
  {
    id: 'bh-004',
    category: 'behavioral',
    subcategory: 'technical-explanations',
    title: 'Explain Virtual DOM to a Non-Technical PM',
    difficulty: 3,
    type: 'EXPLAIN',
    description: 'Explain React\'s Virtual DOM to a non-technical project manager who wants to understand why your team chose React. Avoid jargon. Use analogies. Make them understand the benefit without needing to understand the implementation.',
    solution: 'Imagine you are editing a long Word document and you want to change one paragraph. You have two approaches:\n\nApproach 1 (No Virtual DOM): Delete the entire document and retype the whole thing from scratch every time you change one word. This is what a web page traditionally does — when something changes, the browser rebuilds everything.\n\nApproach 2 (Virtual DOM): Keep a draft copy of your document. When you want to make a change, you edit the draft first. Then you compare the draft to the published version and only update the specific paragraphs that changed. Much faster.\n\nReact\'s Virtual DOM is that draft copy. When data changes in our app (like a user adding an item to their cart), React first updates its lightweight draft. Then it compares the draft to what is actually on screen and makes the minimum possible changes.\n\nWhy this matters for our project:\n- Speed: Users see updates instantly because we are only changing what needs to change, not rebuilding the entire page.\n- Reliability: React calculates the exact changes needed, reducing bugs from manual page manipulation.\n- Developer productivity: Our engineers describe WHAT the page should look like, and React figures out HOW to get there efficiently.\n\nThe bottom line: React makes our app fast and our developers productive, which means we can ship features faster with fewer bugs.',
    solutionExplanation: 'This tests your ability to communicate technical concepts to non-technical stakeholders. The key skills: (1) use a relatable analogy (Word document), (2) explain the benefit before the mechanism, (3) connect to business value (speed, reliability, productivity), (4) avoid jargon entirely (no "DOM", "reconciliation", "state"). The worst answer is a technically accurate but jargon-heavy explanation that the PM cannot follow.',
    hints: ['Start with an analogy from everyday life. The PM does not need to understand the implementation — they need to understand the BENEFIT.', 'Connect the technical concept to business outcomes: speed, reliability, developer productivity, cost.'],
    tags: ['technical-communication', 'react', 'virtual-dom', 'non-technical-audience'],
    estimatedMinutes: 8,
  },
  {
    id: 'bh-005',
    category: 'behavioral',
    subcategory: 'technical-explanations',
    title: 'Explain Microservices vs Monolith',
    difficulty: 3,
    type: 'EXPLAIN',
    description: 'Explain the trade-offs between microservices and monolith architectures. Be balanced — present genuine advantages and disadvantages of each. When would you recommend one over the other?',
    solution: 'Monolith Architecture:\nOne application, one codebase, one deployment.\n\nAdvantages:\n- Simple to develop, test, deploy, and debug\n- No network calls between components — function calls are fast and reliable\n- Easier to maintain data consistency (single database, ACID transactions)\n- Lower operational overhead (one thing to monitor, scale, deploy)\n- Better for small teams (no coordination overhead)\n\nDisadvantages:\n- Entire app must be deployed together (one change = full redeploy)\n- Scaling is all-or-nothing (cannot scale just the payment processing)\n- Technology lock-in (whole app uses one language/framework)\n- Large codebase becomes harder to understand over time\n- One bug can bring down the entire application\n\nMicroservices Architecture:\nMany small services, each independently deployed and scaled.\n\nAdvantages:\n- Independent deployment (change payment service without touching user service)\n- Independent scaling (scale the service that needs it)\n- Technology diversity (use the right tool for each service)\n- Fault isolation (one service crash does not bring down everything)\n- Team autonomy (each team owns their service end-to-end)\n\nDisadvantages:\n- Distributed system complexity (network failures, latency, partial failures)\n- Data consistency is hard (no cross-service transactions, eventual consistency)\n- Operational overhead (many things to deploy, monitor, log, debug)\n- Integration testing is harder\n- Requires organizational maturity (DevOps culture, CI/CD, observability)\n\nRecommendation:\nStart with a well-structured monolith. Extract services when you have a specific reason (scaling needs, team boundaries, independent deployment requirements). Most applications never need microservices. The worst outcome is a "distributed monolith" — microservices that are tightly coupled and deployed together, giving you the complexity of both with the benefits of neither.',
    solutionExplanation: 'This tests architectural maturity. Junior engineers default to "microservices are better." Senior engineers know that monoliths are simpler and sufficient for most applications. The key insight is the "distributed monolith" anti-pattern and the recommendation to start simple. Strong answers are balanced and specific about WHEN each approach is appropriate, not dogmatic about either.',
    hints: ['Be genuinely balanced. Each approach has real advantages. The strongest answer explains WHEN each is appropriate, not which is "better."', 'Address the "distributed monolith" anti-pattern: microservices that are tightly coupled give you the complexity of both approaches with the benefits of neither.'],
    tags: ['architecture', 'microservices', 'monolith', 'trade-offs', 'system-design'],
    estimatedMinutes: 10,
  },
  {
    id: 'bh-006',
    category: 'behavioral',
    subcategory: 'technical-explanations',
    title: 'Explain Database Indexing to a Junior',
    difficulty: 2,
    type: 'EXPLAIN',
    description: 'Explain database indexing to a junior developer who knows SQL basics but has never worked with indexes. Help them understand what indexes are, why they matter, and when to use them.',
    solution: 'Think of a database table as a thick textbook. When you run a query like "SELECT * FROM users WHERE email = \'alice@example.com\'", the database needs to find that row.\n\nWithout an index: The database reads every single row in the table and checks if the email matches. If you have 1 million users, it checks all 1 million rows. This is called a "full table scan." It is like reading a textbook cover to cover to find one topic.\n\nWith an index on the email column: The database maintains a separate sorted data structure (like the index at the back of a textbook) that maps email values to row locations. It can jump directly to "alice@example.com" in O(log n) time — about 20 comparisons for a million rows instead of a million.\n\nWhen to add an index:\n- Columns you frequently search by (WHERE clauses)\n- Columns you join on (JOIN conditions)\n- Columns you sort by (ORDER BY)\n\nWhen NOT to add an index:\n- Tables with very few rows (scanning 100 rows is already fast)\n- Columns you rarely query\n- Tables where writes are much more frequent than reads\n\nThe cost: Indexes are not free. Every time you INSERT, UPDATE, or DELETE a row, all indexes on that table must be updated too. Think of it like this: if your textbook has 10 indexes at the back, every time you add a page, you have to update all 10 indexes.\n\nPractical advice:\n1. Always index your primary key (this is automatic)\n2. Index foreign keys (columns used in JOINs)\n3. Index columns used in frequently slow queries\n4. Use EXPLAIN to see if your query is using indexes\n5. Do not add indexes "just in case" — measure first',
    solutionExplanation: 'Teaching ability is a key senior skill. This answer uses the textbook analogy consistently, builds from the problem (full scan) to the solution (index), covers both benefits and costs, and gives practical advice. It avoids over-explaining B-tree internals that a junior does not need yet.',
    hints: ['Start with a concrete analogy they can relate to (book index, phone book, dictionary). Build from there.', 'Cover both the benefit AND the cost. Indexes make reads faster but writes slower.'],
    tags: ['teaching', 'database', 'indexing', 'mentoring', 'junior-developer'],
    estimatedMinutes: 8,
  },
  {
    id: 'bh-007',
    category: 'behavioral',
    subcategory: 'tradeoff-discussions',
    title: 'SQL vs NoSQL: How Do You Decide?',
    difficulty: 3,
    type: 'EXPLAIN',
    description: 'When building a new application, how do you decide between SQL (PostgreSQL, MySQL) and NoSQL (MongoDB, DynamoDB) databases? Discuss the trade-offs and give concrete examples of when each is appropriate.',
    solution: 'The decision depends on your data characteristics, query patterns, scale requirements, and team expertise.\n\nChoose SQL (Relational) when:\n- Data has clear relationships (users have orders, orders have items)\n- You need ACID transactions (financial systems, inventory management)\n- Query patterns are complex (JOINs, aggregations, GROUP BY)\n- Data structure is stable and well-understood\n- You need strong consistency (read-after-write guarantee)\nExamples: E-commerce platforms, banking systems, CRM applications, most CRUD applications\n\nChoose NoSQL when:\n- Data is naturally document-shaped (user profiles with nested preferences)\n- Schema changes frequently (early-stage startups iterating fast)\n- Read/write patterns are simple (key-value lookup, document fetch)\n- You need horizontal scaling for very high throughput\n- Data is semi-structured or varies between records\nExamples: Content management systems, real-time analytics, IoT data, user session storage, caching\n\nCommon Misconceptions:\n- "NoSQL is faster" — not inherently. A properly indexed SQL query is fast. NoSQL avoids JOIN overhead but cannot perform complex queries efficiently.\n- "NoSQL scales better" — SQL databases (PostgreSQL) can handle millions of rows. You need NoSQL-level horizontal scaling at very large scale (millions of writes per second).\n- "NoSQL is schemaless" — you still have an implicit schema. It is just enforced in application code instead of the database, which can be worse.\n\nDefault Recommendation: Start with PostgreSQL. It handles JSON documents (JSONB), full-text search, and most NoSQL use cases adequately. Only choose a specialized NoSQL database when you have a specific requirement that PostgreSQL cannot meet.',
    solutionExplanation: 'This tests pragmatic decision-making. The strongest signal is avoiding dogmatism. Junior engineers often choose NoSQL because it is "modern." Senior engineers default to proven tools (PostgreSQL) and switch only when requirements demand it. The recommendation to "start with PostgreSQL" shows practical experience.',
    hints: ['Avoid being dogmatic. Both are tools with different strengths. The question is testing whether you can make nuanced decisions.', 'Consider: what are your data relationships? What are your consistency requirements? What queries will you run? How much data and throughput do you expect?'],
    tags: ['database', 'sql', 'nosql', 'trade-offs', 'architecture'],
    estimatedMinutes: 10,
  },
  {
    id: 'bh-008',
    category: 'behavioral',
    subcategory: 'tradeoff-discussions',
    title: 'SSR vs CSR: When to Choose Each',
    difficulty: 3,
    type: 'EXPLAIN',
    description: 'When would you choose Server-Side Rendering (SSR) over Client-Side Rendering (CSR), and vice versa? Discuss the trade-offs including performance, SEO, complexity, and user experience. Include where Next.js fits in.',
    solution: 'Client-Side Rendering (CSR) — React SPA:\nThe server sends an empty HTML shell. JavaScript downloads, executes, and renders content in the browser.\n\nPros: Rich interactivity, simpler deployment (static hosting), good for authenticated dashboards, reduced server load.\nCons: Slower initial load (blank page until JS loads), poor SEO (search engines may not execute JS), larger bundle download, poor on slow devices.\nBest for: Internal tools, dashboards, apps behind login, highly interactive applications.\n\nServer-Side Rendering (SSR):\nThe server renders HTML for each request and sends complete HTML to the browser. JavaScript then "hydrates" to add interactivity.\n\nPros: Fast initial paint (HTML arrives ready), excellent SEO, works without JavaScript, better for slow devices.\nCons: Server load per request, more complex infrastructure, TTFB depends on server speed, full page data must be fetched server-side.\nBest for: Content sites, e-commerce, marketing pages, any page that needs SEO.\n\nStatic Site Generation (SSG):\nPages are pre-rendered at build time. Best of both worlds for content that does not change per request.\n\nPros: Fastest possible delivery (CDN cached), no server needed at runtime, excellent SEO.\nCons: Content is stale until rebuild, does not work for dynamic/personalized content.\nBest for: Blogs, documentation, marketing sites.\n\nWhere Next.js Fits:\nNext.js gives you all three options per page. This is its key advantage — you pick the rendering strategy that fits each page:\n- Marketing pages: SSG (static, fast, SEO)\n- Product pages: SSR (dynamic data, SEO needed)\n- User dashboard: CSR (authenticated, interactive, no SEO)\n- Blog: SSG with Incremental Static Regeneration (ISR)\n\nDefault recommendation: Use SSR/SSG for public-facing pages, CSR for authenticated interactive features. Next.js makes this natural with its hybrid approach.',
    solutionExplanation: 'This tests understanding of rendering trade-offs. The strongest answer covers all three strategies (CSR, SSR, SSG), gives concrete use cases for each, and explains Next.js as a hybrid solution that lets you choose per page. Avoid blanket statements like "SSR is always better." The right answer is always "it depends on the page."',
    hints: ['Consider three rendering strategies, not two: CSR, SSR, and SSG (static). Each has a sweet spot.', 'The strongest answer uses Next.js as an example of picking the right strategy per page, not forcing one approach on the entire application.'],
    tags: ['ssr', 'csr', 'ssg', 'next.js', 'rendering', 'trade-offs', 'seo'],
    estimatedMinutes: 10,
  }
];
