import type { Challenge } from '../../types';

export const algorithmChallenges: Challenge[] = [
  {
    id: 'algo-001',
    category: 'algorithms',
    subcategory: 'hash-maps',
    title: 'Two Sum',
    difficulty: 1,
    type: 'CODE',
    description: 'Given an array of integers and a target, return the indices of two numbers that add up to the target. Each input has exactly one solution, and you may not use the same element twice. Optimize for O(n) time complexity using a hash map.',
    starterCode: `function twoSum(nums, target) {\n  // Your code here\n}`,
    solution: `function twoSum(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    map.set(nums[i], i);\n  }\n  return [];\n}`,
    solutionExplanation: 'Instead of brute-force O(n^2) with nested loops, we use a hash map for O(1) lookups. For each number, we calculate its complement (target - num) and check if we have already seen it. If yes, return both indices. If no, store the current number and its index. This gives O(n) time and O(n) space.',
    hints: ['For each number, what other number would you need to reach the target?', 'Store previously seen numbers in a hash map for O(1) lookup.'],
    testCases: [
      { input: 'twoSum([2,7,11,15], 9)', expectedOutput: '[0,1]', description: 'Basic case: 2+7=9' },
      { input: 'twoSum([3,2,4], 6)', expectedOutput: '[1,2]', description: 'Non-adjacent elements: 2+4=6' },
      { input: 'twoSum([3,3], 6)', expectedOutput: '[0,1]', description: 'Duplicate values: 3+3=6' }
    ],
    tags: ['hash-map', 'array', 'complement'],
    estimatedMinutes: 10,
  },
  {
    id: 'algo-002',
    category: 'algorithms',
    subcategory: 'two-pointers',
    title: 'Valid Palindrome',
    difficulty: 1,
    type: 'CODE',
    description: 'Given a string, determine if it is a palindrome considering only alphanumeric characters and ignoring case. Use the two-pointer technique for O(n) time and O(1) space.',
    starterCode: `function isPalindrome(s) {\n  // Your code here\n}`,
    solution: `function isPalindrome(s) {\n  let left = 0;\n  let right = s.length - 1;\n\n  while (left < right) {\n    while (left < right && !isAlphaNum(s[left])) left++;\n    while (left < right && !isAlphaNum(s[right])) right--;\n\n    if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;\n}\n\nfunction isAlphaNum(c) {\n  return /[a-zA-Z0-9]/.test(c);\n}`,
    solutionExplanation: 'Two pointers start from both ends and move inward. We skip non-alphanumeric characters and compare lowercase versions of the remaining characters. If any pair does not match, it is not a palindrome. O(n) time, O(1) space since we only use two pointer variables.',
    hints: ['Start two pointers at the beginning and end. Move them toward each other.', 'Skip non-alphanumeric characters and compare in lowercase.'],
    testCases: [
      { input: 'isPalindrome("A man, a plan, a canal: Panama")', expectedOutput: 'true', description: 'Classic palindrome with punctuation' },
      { input: 'isPalindrome("race a car")', expectedOutput: 'false', description: 'Not a palindrome' },
      { input: 'isPalindrome(" ")', expectedOutput: 'true', description: 'Empty/whitespace is palindrome' }
    ],
    tags: ['two-pointers', 'string', 'palindrome'],
    estimatedMinutes: 8,
  },
  {
    id: 'algo-003',
    category: 'algorithms',
    subcategory: 'two-pointers',
    title: 'Container With Most Water',
    difficulty: 2,
    type: 'CODE',
    description: 'Given an array of heights, find two lines that together with the x-axis form a container holding the most water. Return the maximum amount of water. Use two-pointer technique for O(n) time.',
    starterCode: `function maxArea(height) {\n  // Your code here\n}`,
    solution: `function maxArea(height) {\n  let left = 0;\n  let right = height.length - 1;\n  let maxWater = 0;\n\n  while (left < right) {\n    const width = right - left;\n    const h = Math.min(height[left], height[right]);\n    maxWater = Math.max(maxWater, width * h);\n\n    if (height[left] < height[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n\n  return maxWater;\n}`,
    solutionExplanation: 'Start with the widest container (pointers at both ends). The area is min(height[left], height[right]) * width. To potentially find a larger container, move the pointer with the shorter height inward — moving the taller one can only decrease the area since width decreases and height is limited by the shorter side. This greedy approach ensures we check all potentially optimal containers in O(n) time.',
    hints: ['Start with pointers at both ends (widest container). Area = min(heights) * width.', 'Which pointer should you move? Moving the shorter one might find a taller line. Moving the taller one can only make things worse.'],
    testCases: [
      { input: 'maxArea([1,8,6,2,5,4,8,3,7])', expectedOutput: '49', description: 'Classic example: lines at index 1 and 8' },
      { input: 'maxArea([1,1])', expectedOutput: '1', description: 'Two equal heights' },
      { input: 'maxArea([4,3,2,1,4])', expectedOutput: '16', description: 'Equal heights at both ends' }
    ],
    tags: ['two-pointers', 'greedy', 'array'],
    estimatedMinutes: 12,
  },
  {
    id: 'algo-004',
    category: 'algorithms',
    subcategory: 'sliding-window',
    title: 'Longest Substring Without Repeating Characters',
    difficulty: 3,
    type: 'CODE',
    description: 'Given a string, find the length of the longest substring without repeating characters. Use the sliding window technique with a hash set or map for O(n) time.',
    starterCode: `function lengthOfLongestSubstring(s) {\n  // Your code here\n}`,
    solution: `function lengthOfLongestSubstring(s) {\n  const charIndex = new Map();\n  let maxLen = 0;\n  let start = 0;\n\n  for (let end = 0; end < s.length; end++) {\n    const char = s[end];\n    if (charIndex.has(char) && charIndex.get(char) >= start) {\n      start = charIndex.get(char) + 1;\n    }\n    charIndex.set(char, end);\n    maxLen = Math.max(maxLen, end - start + 1);\n  }\n\n  return maxLen;\n}`,
    solutionExplanation: 'The sliding window maintains a range [start, end] where all characters are unique. We expand end one character at a time. If the new character was seen before AND its last position is within our current window (>= start), we shrink the window by moving start past the duplicate. A Map stores the last index of each character for O(1) lookup. This achieves O(n) time since each character is processed at most twice.',
    hints: ['Maintain a window [start, end]. Use a Map to store the last index of each character.', 'When you find a duplicate, do not shrink one by one. Jump start directly past the previous occurrence.'],
    testCases: [
      { input: 'lengthOfLongestSubstring("abcabcbb")', expectedOutput: '3', description: '"abc" is the longest' },
      { input: 'lengthOfLongestSubstring("bbbbb")', expectedOutput: '1', description: 'All same characters' },
      { input: 'lengthOfLongestSubstring("pwwkew")', expectedOutput: '3', description: '"wke" is the longest' },
      { input: 'lengthOfLongestSubstring("")', expectedOutput: '0', description: 'Empty string' }
    ],
    tags: ['sliding-window', 'hash-map', 'string'],
    estimatedMinutes: 12,
  },
  {
    id: 'algo-005',
    category: 'algorithms',
    subcategory: 'sliding-window',
    title: 'Maximum Subarray Sum (Kadane)',
    difficulty: 2,
    type: 'CODE',
    description: 'Given an integer array, find the contiguous subarray with the largest sum. Implement Kadane\'s algorithm for O(n) time and O(1) space.',
    starterCode: `function maxSubArray(nums) {\n  // Your code here\n}`,
    solution: `function maxSubArray(nums) {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n\n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n\n  return maxSum;\n}`,
    solutionExplanation: 'Kadane\'s algorithm tracks the maximum sum ending at each position. At each element, we decide: is it better to extend the previous subarray (currentSum + nums[i]) or start a new one (nums[i])? If the running sum becomes negative, starting fresh is always better. We track the global maximum across all positions. O(n) time, O(1) space.',
    hints: ['At each position, you have two choices: extend the previous subarray or start a new one. Choose whichever gives a larger sum.', 'Keep track of both the current running sum and the overall maximum seen so far.'],
    testCases: [
      { input: 'maxSubArray([-2,1,-3,4,-1,2,1,-5,4])', expectedOutput: '6', description: 'Subarray [4,-1,2,1] = 6' },
      { input: 'maxSubArray([1])', expectedOutput: '1', description: 'Single element' },
      { input: 'maxSubArray([-1])', expectedOutput: '-1', description: 'Single negative element' },
      { input: 'maxSubArray([5,4,-1,7,8])', expectedOutput: '23', description: 'All positive sum' }
    ],
    tags: ['dynamic-programming', 'kadane', 'array', 'subarray'],
    estimatedMinutes: 10,
  },
  {
    id: 'algo-006',
    category: 'algorithms',
    subcategory: 'hash-maps',
    title: 'Group Anagrams',
    difficulty: 2,
    type: 'CODE',
    description: 'Given an array of strings, group the anagrams together. Two strings are anagrams if they contain the same characters in any order. Return the groups in any order.',
    starterCode: `function groupAnagrams(strs) {\n  // Your code here\n}`,
    solution: `function groupAnagrams(strs) {\n  const map = new Map();\n\n  for (const str of strs) {\n    const key = str.split('').sort().join('');\n    if (!map.has(key)) map.set(key, []);\n    map.get(key).push(str);\n  }\n\n  return Array.from(map.values());\n}`,
    solutionExplanation: 'Anagrams produce the same string when sorted. We use the sorted string as a hash map key to group anagrams together. For each string, sort its characters and use that as the key. All anagrams will have the same key. Time complexity: O(n * k log k) where k is the max string length (due to sorting). Alternative: use character frequency count as key for O(n * k) time.',
    hints: ['What property do all anagrams share? They have the same characters, just in different order.', 'If you sort the characters of an anagram, all anagrams produce the same sorted string. Use that as a hash map key.'],
    testCases: [
      { input: 'groupAnagrams(["eat","tea","tan","ate","nat","bat"])', expectedOutput: '[["eat","tea","ate"],["tan","nat"],["bat"]]', description: 'Standard grouping' },
      { input: 'groupAnagrams([""])', expectedOutput: '[[""]]', description: 'Empty string' },
      { input: 'groupAnagrams(["a"])', expectedOutput: '[["a"]]', description: 'Single character' }
    ],
    tags: ['hash-map', 'sorting', 'string', 'anagram'],
    estimatedMinutes: 10,
  },
  {
    id: 'algo-007',
    category: 'algorithms',
    subcategory: 'stacks-queues',
    title: 'Valid Parentheses',
    difficulty: 1,
    type: 'CODE',
    description: 'Given a string containing just the characters (, ), {, }, [, and ], determine if the input string is valid. An input string is valid if open brackets are closed by the same type and in the correct order.',
    starterCode: `function isValid(s) {\n  // Your code here\n}`,
    solution: `function isValid(s) {\n  const stack = [];\n  const pairs = { ')': '(', '}': '{', ']': '[' };\n\n  for (const char of s) {\n    if (char === '(' || char === '{' || char === '[') {\n      stack.push(char);\n    } else {\n      if (stack.length === 0 || stack[stack.length - 1] !== pairs[char]) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n\n  return stack.length === 0;\n}`,
    solutionExplanation: 'A stack naturally handles nested matching. Push opening brackets onto the stack. When we see a closing bracket, check if the top of the stack matches. If not, the string is invalid. At the end, the stack must be empty (all brackets matched). O(n) time, O(n) space.',
    hints: ['Use a stack. Push opening brackets, pop on closing brackets.', 'A closing bracket must match the most recent unmatched opening bracket (top of stack).'],
    testCases: [
      { input: 'isValid("()")', expectedOutput: 'true', description: 'Simple pair' },
      { input: 'isValid("()[]{}")', expectedOutput: 'true', description: 'Multiple types' },
      { input: 'isValid("(]")', expectedOutput: 'false', description: 'Mismatched types' },
      { input: 'isValid("([)]")', expectedOutput: 'false', description: 'Wrong nesting order' },
      { input: 'isValid("{[]}")', expectedOutput: 'true', description: 'Nested brackets' }
    ],
    tags: ['stack', 'string', 'matching'],
    estimatedMinutes: 8,
  },
  {
    id: 'algo-008',
    category: 'algorithms',
    subcategory: 'stacks-queues',
    title: 'Daily Temperatures',
    difficulty: 3,
    type: 'CODE',
    description: 'Given an array of daily temperatures, return an array where each element tells you how many days you would have to wait until a warmer temperature. If there is no future warmer day, put 0. Use a monotonic stack for O(n) time.',
    starterCode: `function dailyTemperatures(temperatures) {\n  // Your code here\n}`,
    solution: `function dailyTemperatures(temperatures) {\n  const n = temperatures.length;\n  const result = new Array(n).fill(0);\n  const stack = []; // stores indices\n\n  for (let i = 0; i < n; i++) {\n    while (stack.length > 0 && temperatures[i] > temperatures[stack[stack.length - 1]]) {\n      const prevIndex = stack.pop();\n      result[prevIndex] = i - prevIndex;\n    }\n    stack.push(i);\n  }\n\n  return result;\n}`,
    solutionExplanation: 'A monotonic decreasing stack stores indices of temperatures we haven not found a warmer day for yet. When we encounter a temperature warmer than the stack top, we pop and calculate the day difference. This works because the stack maintains decreasing order — each pop finds the NEXT warmer day for that index. Every index is pushed and popped at most once, giving O(n) time.',
    hints: ['Use a stack to keep track of indices where we have not yet found a warmer day.', 'When the current temperature is higher than the stack top, that means we found the answer for that index. Pop it and record the difference.'],
    testCases: [
      { input: 'dailyTemperatures([73,74,75,71,69,72,76,73])', expectedOutput: '[1,1,4,2,1,1,0,0]', description: 'Standard case' },
      { input: 'dailyTemperatures([30,40,50,60])', expectedOutput: '[1,1,1,0]', description: 'Always increasing' },
      { input: 'dailyTemperatures([30,20,10])', expectedOutput: '[0,0,0]', description: 'Always decreasing' }
    ],
    tags: ['monotonic-stack', 'array', 'next-greater-element'],
    estimatedMinutes: 15,
  },
  {
    id: 'algo-009',
    category: 'algorithms',
    subcategory: 'trees',
    title: 'Validate Binary Search Tree',
    difficulty: 3,
    type: 'CODE',
    description: 'Given the root of a binary tree, determine if it is a valid BST. A valid BST has the property that all nodes in the left subtree are less than the current node, and all nodes in the right subtree are greater. Note: it is not enough to only check immediate children.',
    starterCode: `// TreeNode: { val, left, right }\nfunction isValidBST(root) {\n  // Your code here\n}`,
    solution: `function isValidBST(root) {\n  function validate(node, min, max) {\n    if (!node) return true;\n    if (node.val <= min || node.val >= max) return false;\n    return validate(node.left, min, node.val) && validate(node.right, node.val, max);\n  }\n  return validate(root, -Infinity, Infinity);\n}`,
    solutionExplanation: 'The common mistake is only checking if left child < node < right child. That misses cases where a deeper node violates the BST property relative to an ancestor. Instead, pass down valid range bounds: left subtree nodes must be in (min, node.val), right subtree nodes must be in (node.val, max). Start with (-Infinity, Infinity). This recursive approach is O(n) time, O(h) space where h is tree height.',
    hints: ['Do not just check immediate children. A left subtree node could be greater than a grandparent, violating BST property.', 'Pass valid range (min, max) down the recursion. Left child narrows max, right child narrows min.'],
    testCases: [
      { input: 'isValidBST({val:2, left:{val:1,left:null,right:null}, right:{val:3,left:null,right:null}})', expectedOutput: 'true', description: 'Simple valid BST' },
      { input: 'isValidBST({val:5, left:{val:1,left:null,right:null}, right:{val:4,left:{val:3,left:null,right:null},right:{val:6,left:null,right:null}}})', expectedOutput: 'false', description: 'Right child 4 < root 5' },
      { input: 'isValidBST(null)', expectedOutput: 'true', description: 'Empty tree is valid' }
    ],
    tags: ['tree', 'bst', 'recursion', 'dfs'],
    estimatedMinutes: 12,
  },
  {
    id: 'algo-010',
    category: 'algorithms',
    subcategory: 'dynamic-programming',
    title: 'Climbing Stairs',
    difficulty: 2,
    type: 'CODE',
    description: 'You are climbing a staircase with n steps. Each time you can climb 1 or 2 steps. How many distinct ways can you reach the top? This is a classic introduction to dynamic programming and follows the Fibonacci pattern.',
    starterCode: `function climbStairs(n) {\n  // Your code here\n}`,
    solution: `function climbStairs(n) {\n  if (n <= 2) return n;\n  let prev2 = 1; // ways to reach step 1\n  let prev1 = 2; // ways to reach step 2\n\n  for (let i = 3; i <= n; i++) {\n    const current = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = current;\n  }\n\n  return prev1;\n}`,
    solutionExplanation: 'To reach step n, you either came from step n-1 (1 step) or step n-2 (2 steps). So ways(n) = ways(n-1) + ways(n-2), which is the Fibonacci recurrence. The naive recursive solution is O(2^n). Memoization makes it O(n) time, O(n) space. The optimized iterative solution uses O(1) space by only tracking the last two values since we only need prev1 and prev2 to compute the current step.',
    hints: ['Think about how you arrive at step n. You must come from step n-1 or step n-2. So the number of ways is the sum of both.', 'This is the Fibonacci sequence. Optimize from O(n) space to O(1) by only keeping the last two values.'],
    testCases: [
      { input: 'climbStairs(2)', expectedOutput: '2', description: '2 ways: 1+1 or 2' },
      { input: 'climbStairs(3)', expectedOutput: '3', description: '3 ways: 1+1+1, 1+2, 2+1' },
      { input: 'climbStairs(5)', expectedOutput: '8', description: '8 distinct ways' },
      { input: 'climbStairs(1)', expectedOutput: '1', description: 'Only 1 way for 1 step' }
    ],
    tags: ['dynamic-programming', 'fibonacci', 'optimization'],
    estimatedMinutes: 8,
  }
];
